<!DOCTYPE html>
<html lang="zh-CN">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>P2P通信 - 设备端 (Device Simulator)</title>
    <script src="https://unpkg.com/mqtt/dist/mqtt.min.js"></script>
    <style>
        body {
            font-family: Arial, sans-serif;
            max-width: 800px;
            margin: 0 auto;
            padding: 20px;
            background-color: #f0f2f5;
        }

        .container {
            background: white;
            border-radius: 8px;
            padding: 20px;
            box-shadow: 0 2px 10px rgba(0, 0, 0, 0.1);
            margin-bottom: 20px;
        }

        h1,
        h2 {
            color: #333;
        }

        .form-grid {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 15px;
            margin-bottom: 20px;
        }

        .form-group label {
            display: block;
            margin-bottom: 5px;
            font-weight: bold;
        }

        .form-group input {
            width: 100%;
            padding: 8px;
            border: 1px solid #ddd;
            border-radius: 4px;
            box-sizing: border-box;
        }

        video {
            width: 100%;
            border-radius: 8px;
            background: #000;
        }

        .controls {
            display: flex;
            gap: 10px;
            margin-bottom: 20px;
        }

        button {
            padding: 10px 15px;
            border: none;
            border-radius: 5px;
            cursor: pointer;
            font-size: 14px;
            transition: background-color 0.3s;
        }

        .btn-primary {
            background-color: #007bff;
            color: white;
        }

        .btn-primary:hover {
            background-color: #0056b3;
        }

        .btn-danger {
            background-color: #dc3545;
            color: white;
        }

        .btn-danger:hover {
            background-color: #c82333;
        }

        .status {
            padding: 10px;
            border-radius: 4px;
            font-weight: bold;
            margin-bottom: 10px;
        }

        .status.connected {
            background-color: #d4edda;
            color: #155724;
            border: 1px solid #c3e6cb;
        }

        .status.disconnected {
            background-color: #f8d7da;
            color: #721c24;
            border: 1px solid #f5c6cb;
        }

        .status.connecting {
            background-color: #fff3cd;
            color: #856404;
            border: 1px solid #ffeaa7;
        }

        .status.waiting {
            background-color: #cce5ff;
            color: #004085;
            border: 1px solid #b8daff;
        }

        .log {
            background: #e9ecef;
            border: 1px solid #dee2e6;
            border-radius: 4px;
            padding: 15px;
            height: 250px;
            overflow-y: auto;
            font-family: monospace;
            font-size: 12px;
            white-space: pre-wrap;
        }

        #audioCanvas {
            display: block;
            margin: 10px 0;
            border-radius: 8px;
        }

        .audio-visualizer {
            background: #000;
            border-radius: 8px;
            padding: 10px;
            margin-bottom: 20px;
        }
    </style>
</head>

<body>
    <div class="container">
        <h1>P2P通信 - 设备端 (Device Simulator)</h1>

        <div class="form-grid">
            <div class="form-group">
                <label for="productKey">产品密钥 (Product Key):</label>
                <input type="text" id="productKey" value="PLAF204">
            </div>
            <div class="form-group">
                <label for="deviceSn">设备序列号 (Device SN):</label>
                <input type="text" id="deviceSn" value="AF070135F064641AG">
            </div>
        </div>

        <div id="mqttStatus" class="status disconnected">MQTT状态: 未连接</div>
        <div id="p2pStatus" class="status waiting">P2P状态: 等待P2P配置</div>

        <h2>本地视频 (发送给APP)</h2>
        <video id="localVideo" autoplay muted playsinline></video>
        <!-- 远程音频(来自APP)会自动播放，无需可见元素 -->
        <audio id="remoteAudio" autoplay playsinline></audio>

        <h2>音频可视化 (来自APP)</h2>
        <div class="audio-visualizer">
            <canvas id="audioCanvas" width="740" height="200"
                style="border: 1px solid #ccc; background: #000;"></canvas>
            <div style="margin-top: 10px; text-align: center;">
                <button id="toggleVisualizationBtn" class="btn-primary" style="margin-right: 10px;">暂停可视化</button>
                <button id="startAudioBtn" class="btn-primary"
                    style="margin-right: 10px; background-color: #28a745;">启动音频</button>
                <span id="visualizationStatus" style="color: #00ff00; font-weight: bold;">等待音频启动</span>
            </div>
            <div id="audioHint" style="margin-top: 10px; text-align: center; color: #ff9900; font-size: 14px;">
                提示：P2P连接成功后会自动启动音频可视化，如果无显示请点击"启动音频"按钮
            </div>
        </div>

        <div class="controls">
            <button id="startBtn" class="btn-primary">启动设备</button>
            <button id="stopBtn" class="btn-danger" disabled>停止设备</button>
        </div>

        <h2>日志</h2>
        <div id="logArea" class="log"></div>
    </div>

    <script>
        class P2PDevice {
            constructor() {
                this.elements = {
                    productKey: document.getElementById('productKey'),
                    deviceSn: document.getElementById('deviceSn'),
                    mqttStatus: document.getElementById('mqttStatus'),
                    p2pStatus: document.getElementById('p2pStatus'),
                    localVideo: document.getElementById('localVideo'),
                    remoteAudio: document.getElementById('remoteAudio'),
                    audioCanvas: document.getElementById('audioCanvas'),
                    toggleVisualizationBtn: document.getElementById('toggleVisualizationBtn'),
                    startAudioBtn: document.getElementById('startAudioBtn'),
                    visualizationStatus: document.getElementById('visualizationStatus'),
                    audioHint: document.getElementById('audioHint'),
                    startBtn: document.getElementById('startBtn'),
                    stopBtn: document.getElementById('stopBtn'),
                    logArea: document.getElementById('logArea'),
                };

                this.pc = null;
                this.localStream = null;
                this.mqttClient = null;

                this.currentSessionId = null;
                this.currentAppId = null;
                this.rtcConfig = null; // 将从MQTT获取
                this.isNegotiating = false; // 解决竞争状态的信令锁

                // 音频可视化相关
                this.audioContext = null;
                this.analyser = null;
                this.audioSource = null;
                this.visualizationData = null;
                this.isVisualizing = false;

                this.mqttBroker = 'ws://192.168.10.120:8083/mqtt';

                this.setupEventListeners();
                this.log('设备端已初始化。正在自动启动设备...');

                // 初始化音频可视化状态
                this.elements.visualizationStatus.textContent = '等待音频启动';
                this.elements.visualizationStatus.style.color = '#ff9900';
                this.elements.audioHint.textContent = '提示：如果音频可视化无显示，请点击"启动音频"按钮或"测试可视化"按钮';

                // 自动启动设备
                setTimeout(() => this.start(), 500);
            }

            setupEventListeners() {
                this.elements.startBtn.addEventListener('click', () => this.start());
                this.elements.stopBtn.addEventListener('click', () => this.stop());
                this.elements.toggleVisualizationBtn.addEventListener('click', () => this.toggleVisualization());
                this.elements.startAudioBtn.addEventListener('click', () => this.startAudioContext());
            }

            log(message) {
                const timestamp = new Date().toLocaleTimeString();
                this.elements.logArea.textContent += `[${timestamp}] ${message}\n`;
                this.elements.logArea.scrollTop = this.elements.logArea.scrollHeight;
                console.log(`[Device] ${message}`);
            }

            updateMqttStatus(status, className) {
                this.elements.mqttStatus.textContent = `MQTT状态: ${status}`;
                this.elements.mqttStatus.className = `status ${className}`;
            }

            updateP2pStatus(status, className) {
                this.elements.p2pStatus.textContent = `P2P状态: ${status}`;
                this.elements.p2pStatus.className = `status ${className}`;
            }

            // 初始化音频可视化
            initAudioVisualization() {
                try {
                    this.log('初始化音频可视化...');

                    // 检查浏览器支持
                    if (!window.AudioContext && !window.webkitAudioContext) {
                        this.log('浏览器不支持Web Audio API');
                        return false;
                    }

                    // 如果已经有音频上下文且状态正常，直接返回
                    if (this.audioContext && this.audioContext.state === 'running') {
                        this.log('音频上下文已存在且运行正常');
                        return true;
                    }

                    // 创建音频上下文（需要用户交互）
                    this.audioContext = new (window.AudioContext || window.webkitAudioContext)();

                    // 检查音频上下文状态
                    if (this.audioContext.state === 'suspended') {
                        this.log('音频上下文被暂停，需要用户交互才能启动');
                        this.elements.visualizationStatus.textContent = '点击启动音频';
                        this.elements.visualizationStatus.style.color = '#ff9900';
                        // 不返回false，继续创建分析器
                    }

                    this.analyser = this.audioContext.createAnalyser();

                    // 设置分析器参数
                    this.analyser.fftSize = 256;
                    this.analyser.smoothingTimeConstant = 0.8;

                    // 创建数据数组
                    this.visualizationData = new Uint8Array(this.analyser.frequencyBinCount);

                    this.log(`音频可视化初始化完成 - 分析器FFT大小: ${this.analyser.fftSize}, 数据长度: ${this.visualizationData.length}`);
                    return true;
                } catch (error) {
                    this.log(`音频可视化初始化失败: ${error.message}`);
                    return false;
                }
            }

            // 手动启动音频上下文
            async resumeAudioContext() {
                if (this.audioContext && this.audioContext.state === 'suspended') {
                    try {
                        await this.audioContext.resume();
                        this.log('音频上下文已恢复');
                        return true;
                    } catch (error) {
                        this.log(`恢复音频上下文失败: ${error.message}`);
                        return false;
                    }
                }
                return true;
            }

            // 启动音频上下文（用户交互）
            async startAudioContext() {
                this.log('用户点击启动音频按钮...');

                try {
                    // 初始化音频可视化
                    this.initAudioVisualization();

                    // 尝试恢复音频上下文
                    const resumed = await this.resumeAudioContext();

                    if (resumed) {
                        this.log('音频上下文启动成功！');
                        this.elements.visualizationStatus.textContent = '音频已启动';
                        this.elements.visualizationStatus.style.color = '#00ff00';
                        this.elements.audioHint.textContent = '音频上下文已启动，等待P2P连接建立...';
                        this.elements.audioHint.style.color = '#28a745';

                        // 如果有远程音频流，立即启动可视化
                        if (this.elements.remoteAudio.srcObject) {
                            this.log('检测到远程音频流，启动可视化...');
                            setTimeout(() => {
                                this.startAudioVisualization(this.elements.remoteAudio.srcObject);
                            }, 500);
                        } else {
                            this.log('暂无远程音频流，等待P2P连接...');
                        }
                    } else {
                        this.log('音频上下文启动失败');
                        this.elements.visualizationStatus.textContent = '音频启动失败';
                        this.elements.visualizationStatus.style.color = '#ff0000';
                    }
                } catch (error) {
                    this.log(`启动音频上下文失败: ${error.message}`);
                    this.elements.visualizationStatus.textContent = '音频启动失败';
                    this.elements.visualizationStatus.style.color = '#ff0000';
                }
            }

            // 开始音频可视化
            async startAudioVisualization(audioStream) {
                try {
                    this.log('开始音频可视化...');

                    // 检查音频流参数
                    if (!audioStream) {
                        this.log('错误：音频流参数为空');
                        this.elements.visualizationStatus.textContent = '音频流为空';
                        this.elements.visualizationStatus.style.color = '#ff0000';
                        return;
                    }

                    if (!audioStream.getTracks) {
                        this.log('错误：音频流不是有效的MediaStream对象');
                        this.elements.visualizationStatus.textContent = '无效的音频流';
                        this.elements.visualizationStatus.style.color = '#ff0000';
                        return;
                    }

                    const tracks = audioStream.getTracks();
                    this.log(`音频流轨道数量: ${tracks.length}`);

                    if (tracks.length === 0) {
                        this.log('错误：音频流中没有轨道');
                        this.elements.visualizationStatus.textContent = '音频流无轨道';
                        this.elements.visualizationStatus.style.color = '#ff0000';
                        return;
                    }

                    // 检查是否有音频轨道
                    const audioTracks = tracks.filter(track => track.kind === 'audio');
                    if (audioTracks.length === 0) {
                        this.log('错误：音频流中没有音频轨道');
                        this.elements.visualizationStatus.textContent = '无音频轨道';
                        this.elements.visualizationStatus.style.color = '#ff0000';
                        return;
                    }

                    this.log(`音频轨道数量: ${audioTracks.length}`);

                    // 如果音频上下文未初始化或状态不正确，重新初始化
                    if (!this.audioContext || this.audioContext.state === 'closed') {
                        this.log('音频上下文未初始化或已关闭，重新初始化...');
                        this.initAudioVisualization();
                    }

                    // 确保音频上下文处于运行状态
                    if (this.audioContext.state === 'suspended') {
                        this.log('音频上下文被暂停，尝试恢复...');
                        const resumed = await this.resumeAudioContext();

                        if (!resumed) {
                            this.log('音频上下文恢复失败');
                            this.elements.visualizationStatus.textContent = '音频恢复失败';
                            this.elements.visualizationStatus.style.color = '#ff0000';
                            return;
                        }
                    }

                    // 重新创建分析器（如果之前失败）
                    if (!this.analyser || this.analyser.fftSize === 0) {
                        this.log('重新创建音频分析器...');
                        this.analyser = this.audioContext.createAnalyser();
                        this.analyser.fftSize = 256;
                        this.analyser.smoothingTimeConstant = 0.8;
                        this.visualizationData = new Uint8Array(this.analyser.frequencyBinCount);
                    }

                    // 断开之前的连接
                    if (this.audioSource) {
                        this.audioSource.disconnect();
                        this.audioSource = null;
                    }

                    // 创建音频源
                    this.audioSource = this.audioContext.createMediaStreamSource(audioStream);
                    this.audioSource.connect(this.analyser);

                    this.isVisualizing = true;
                    this.elements.visualizationStatus.textContent = '正在可视化';
                    this.elements.visualizationStatus.style.color = '#00ff00';
                    this.elements.toggleVisualizationBtn.textContent = '暂停可视化';

                    // 开始绘制
                    this.drawAudioVisualization();

                    this.log('音频可视化已启动');
                } catch (error) {
                    this.log(`启动音频可视化失败: ${error.message}`);
                    this.log(`错误详情: ${error.stack}`);

                    this.elements.visualizationStatus.textContent = '可视化启动失败';
                    this.elements.visualizationStatus.style.color = '#ff0000';
                }
            }

            // 停止音频可视化
            stopAudioVisualization() {
                this.isVisualizing = false;

                if (this.audioSource) {
                    this.audioSource.disconnect();
                    this.audioSource = null;
                }

                // 清空画布
                const canvas = this.elements.audioCanvas;
                const ctx = canvas.getContext('2d');
                ctx.clearRect(0, 0, canvas.width, canvas.height);

                this.log('音频可视化已停止');
            }

            // 切换音频可视化状态
            toggleVisualization() {
                if (this.isVisualizing) {
                    this.isVisualizing = false;
                    this.elements.toggleVisualizationBtn.textContent = '恢复可视化';
                    this.elements.visualizationStatus.textContent = '已暂停';
                    this.elements.visualizationStatus.style.color = '#ff9900';
                    this.log('音频可视化已暂停');
                } else {
                    this.isVisualizing = true;
                    this.elements.toggleVisualizationBtn.textContent = '暂停可视化';
                    this.elements.visualizationStatus.textContent = '正在可视化';
                    this.elements.visualizationStatus.style.color = '#00ff00';
                    this.drawAudioVisualization();
                    this.log('音频可视化已恢复');
                }
            }



            // 绘制音频可视化
            drawAudioVisualization() {
                if (!this.isVisualizing) {
                    return;
                }

                const canvas = this.elements.audioCanvas;
                const ctx = canvas.getContext('2d');
                const width = canvas.width;
                const height = canvas.height;

                // 清空画布
                ctx.clearRect(0, 0, width, height);

                // 检查分析器是否可用
                if (!this.analyser) {
                    // 显示错误信息
                    ctx.fillStyle = '#ff0000';
                    ctx.font = '16px Arial';
                    ctx.textAlign = 'center';
                    ctx.fillText('音频分析器未初始化', width / 2, height / 2);
                    ctx.fillText('请点击"启动音频"按钮', width / 2, height / 2 + 25);
                    return;
                }

                // 检查音频上下文状态
                if (this.audioContext && this.audioContext.state === 'suspended') {
                    ctx.fillStyle = '#ff9900';
                    ctx.font = '16px Arial';
                    ctx.textAlign = 'center';
                    ctx.fillText('音频上下文被暂停', width / 2, height / 2);
                    ctx.fillText('请点击"启动音频"按钮恢复', width / 2, height / 2 + 25);
                    return;
                }

                // 获取频率数据
                this.analyser.getByteFrequencyData(this.visualizationData);

                // 计算音量级别
                let sum = 0;
                for (let i = 0; i < this.visualizationData.length; i++) {
                    sum += this.visualizationData[i];
                }
                const average = sum / this.visualizationData.length;
                const volumeLevel = average / 255;

                // 显示真实音频模式标识
                ctx.fillStyle = '#00ff00';
                ctx.font = '12px Arial';
                ctx.textAlign = 'left';
                ctx.fillText('真实音频模式', 10, 15);

                // 绘制背景渐变
                const gradient = ctx.createLinearGradient(0, 0, width, 0);
                gradient.addColorStop(0, '#001100');
                gradient.addColorStop(0.5, '#003300');
                gradient.addColorStop(1, '#001100');
                ctx.fillStyle = gradient;
                ctx.fillRect(0, 0, width, height);

                // 绘制频谱柱状图
                const barWidth = width / this.visualizationData.length;
                const barSpacing = 1;
                const actualBarWidth = barWidth - barSpacing;

                for (let i = 0; i < this.visualizationData.length; i++) {
                    const barHeight = (this.visualizationData[i] / 255) * height * 0.8;
                    const x = i * barWidth;
                    const y = height - barHeight;

                    // 根据频率创建颜色渐变
                    const hue = (i / this.visualizationData.length) * 120; // 绿色到黄色
                    const saturation = 100;
                    const lightness = 50 + (this.visualizationData[i] / 255) * 30;

                    ctx.fillStyle = `hsl(${hue}, ${saturation}%, ${lightness}%)`;
                    ctx.fillRect(x, y, actualBarWidth, barHeight);
                }

                // 绘制中心波浪线
                ctx.strokeStyle = '#00ff00';
                ctx.lineWidth = 2;
                ctx.beginPath();

                let x = 0;
                for (let i = 0; i < this.visualizationData.length; i++) {
                    const amplitude = (this.visualizationData[i] / 255) * height * 0.3;
                    const y = height / 2 + Math.sin(i * 0.1 + Date.now() * 0.01) * amplitude;

                    if (i === 0) {
                        ctx.moveTo(x, y);
                    } else {
                        ctx.lineTo(x, y);
                    }

                    x += barWidth;
                }

                ctx.stroke();

                // 绘制音量指示器
                const volumeBarWidth = width * 0.8;
                const volumeBarHeight = 20;
                const volumeBarX = (width - volumeBarWidth) / 2;
                const volumeBarY = height - 30;

                // 背景
                ctx.fillStyle = '#333333';
                ctx.fillRect(volumeBarX, volumeBarY, volumeBarWidth, volumeBarHeight);

                // 音量条
                const volumeFillWidth = volumeBarWidth * volumeLevel;
                const volumeGradient = ctx.createLinearGradient(volumeBarX, 0, volumeBarX + volumeFillWidth, 0);
                volumeGradient.addColorStop(0, '#00ff00');
                volumeGradient.addColorStop(0.5, '#ffff00');
                volumeGradient.addColorStop(1, '#ff0000');

                ctx.fillStyle = volumeGradient;
                ctx.fillRect(volumeBarX, volumeBarY, volumeFillWidth, volumeBarHeight);

                // 音量文字
                ctx.fillStyle = '#ffffff';
                ctx.font = '12px Arial';
                ctx.textAlign = 'center';
                ctx.fillText(`音量: ${Math.round(volumeLevel * 100)}%`, width / 2, height - 10);

                // 绘制中心线
                ctx.strokeStyle = '#444444';
                ctx.lineWidth = 1;
                ctx.beginPath();
                ctx.moveTo(0, height / 2);
                ctx.lineTo(width, height / 2);
                ctx.stroke();

                // 显示调试信息
                ctx.fillStyle = '#ffffff';
                ctx.font = '10px Arial';
                ctx.textAlign = 'left';
                ctx.fillText(`数据长度: ${this.visualizationData.length}`, 10, 30);
                ctx.fillText(`平均音量: ${average.toFixed(1)}`, 10, 45);
                ctx.fillText(`音量级别: ${(volumeLevel * 100).toFixed(1)}%`, 10, 60);

                // 继续动画
                requestAnimationFrame(() => this.drawAudioVisualization());
            }



            start() {
                this.log('正在启动设备...');
                this.elements.startBtn.disabled = true;
                this.elements.stopBtn.disabled = false;
                [this.elements.productKey, this.elements.deviceSn].forEach(el => el.disabled = true);

                // 初始化音频可视化
                this.initAudioVisualization();

                this.connectMqtt();
            }

            stop() {
                this.log('正在停止设备...');
                if (this.mqttClient) {
                    if (this.pc && this.currentAppId) {
                        this.sendSignalingMessage('bye', { reason: 'Device shut down' });
                    }
                    this.mqttClient.end();
                }
                this.closePeerConnection();

                // 停止音频可视化
                this.stopAudioVisualization();

                this.updateMqttStatus('未连接', 'disconnected');
                this.updateP2pStatus('等待P2P配置', 'waiting');
                this.elements.startBtn.disabled = false;
                this.elements.stopBtn.disabled = true;
                [this.elements.productKey, this.elements.deviceSn].forEach(el => el.disabled = false);
                this.log('设备已停止。');
            }

            closePeerConnection() {
                if (this.pc) {
                    this.pc.close();
                    this.pc = null;
                }
                if (this.localStream) {
                    this.localStream.getTracks().forEach(track => track.stop());
                    this.localStream = null;
                }
                this.elements.localVideo.srcObject = null;
                this.elements.remoteAudio.srcObject = null;

                // 停止音频可视化
                this.stopAudioVisualization();

                this.currentSessionId = null;
                this.currentAppId = null;
            }

            connectMqtt() {
                this.log(`正在连接到 MQTT Broker: ${this.mqttBroker}`);
                this.updateMqttStatus('连接中...', 'connecting');

                const options = {
                    clientId: `DEVICE`,
                    username: 'DEVICE',
                    password: 'DEVICE',
                };

                this.mqttClient = mqtt.connect(this.mqttBroker, options);

                this.mqttClient.on('connect', () => {
                    this.updateMqttStatus('已连接', 'connected');
                    this.log('成功连接到 MQTT Broker。');
                    this.subscribeToServiceTopic();
                });

                this.mqttClient.on('message', (topic, message) => {
                    const payload = JSON.parse(message.toString());
                    this.log(`⬇️ [MQTT-IN] Topic: ${topic}\nPayload: ${JSON.stringify(payload, null, 2)}`);

                    if (topic.endsWith('/device/service/sub')) {
                        this.handleP2PConfiguration(payload);
                    } else {
                        this.handleSignalingMessage(payload);
                    }
                });

                this.mqttClient.on('error', (err) => {
                    this.log(`MQTT 错误: ${err}`);
                    this.updateMqttStatus('连接错误', 'disconnected');
                });

                this.mqttClient.on('close', () => {
                    this.log('MQTT 连接已关闭。');
                    this.updateMqttStatus('已断开', 'disconnected');
                });
            }

            subscribeToServiceTopic() {
                const pk = this.elements.productKey.value;
                const sn = this.elements.deviceSn.value;
                const serviceTopic = `dl/${pk}/${sn}/device/service/sub`;

                this.mqttClient.subscribe(serviceTopic, (err) => {
                    if (!err) {
                        this.log(`已订阅设备服务主题: ${serviceTopic}`);
                        this.updateP2pStatus('等待P2P配置...', 'waiting');
                    } else {
                        this.log(`订阅设备服务主题失败: ${err}`);
                    }
                });
            }

            handleP2PConfiguration(config) {
                this.log('收到P2P配置');
                if (config.cmd !== 'P2P_SIGNAL_CONFIG_SERVICE') {
                    this.log(`非P2P配置命令: ${config.cmd}, 忽略。`);
                    return;
                }

                this.currentSessionId = config.sessionId;
                this.currentAppId = config.memberId; // In Java code, memberId is used as app id.

                this.log(`会话ID: ${this.currentSessionId}, APP ID: ${this.currentAppId}`);

                // 解析并应用MQTT下发的RTC配置
                try {
                    this.log('=== 解析MQTT下发的RTC配置 ===');

                    if (config.rtcConfiguration) {
                        const parsedConfig = JSON.parse(config.rtcConfiguration);
                        this.log(`原始MQTT配置: ${JSON.stringify(parsedConfig, null, 2)}`);

                        // 为TURN服务器添加设备端认证信息
                        if (parsedConfig.iceServers) {
                            this.log(`处理ICE服务器配置...`);
                            parsedConfig.iceServers.forEach((server, index) => {
                                if (server.urls.startsWith('turn:')) {
                                    this.log(`配置TURN服务器 ${index + 1}: ${server.urls}`);
                                    // 确保使用udp传输
                                    if (!server.urls.includes('?')) {
                                        server.urls += '?transport=udp';
                                    }
                                    server.username = 'APP'; // 设备端认证
                                    server.credential = 'APP'; // 设备端认证
                                    server.credentialType = 'password';
                                    this.log(`TURN服务器 ${index + 1} 配置完成`);
                                } else if (server.urls.startsWith('stun:')) {
                                    this.log(`STUN服务器 ${index + 1}: ${server.urls}`);
                                }
                            });
                        }

                        this.rtcConfig = parsedConfig;
                        this.log(`=== MQTT RTC配置应用成功 ===`);
                        this.log(`最终配置: ${JSON.stringify(this.rtcConfig, null, 2)}`);
                    } else {
                        throw new Error('MQTT配置中未包含rtcConfiguration字段');
                    }
                } catch (e) {
                    this.log(`解析MQTT RTC配置失败: ${e.message}`);
                    this.log('=== 使用默认配置作为备用方案 ===');

                    // 备用配置
                    this.rtcConfig = {
                        iceServers: [
                            {
                                urls: "stun:223.254.128.13:3478"
                            }
                        ],
                        iceTransportPolicy: "all",
                        iceCandidatePoolSize: 0,
                        bundlePolicy: "max-bundle",
                        rtcpMuxPolicy: "require"
                    };
                    this.log(`备用配置: ${JSON.stringify(this.rtcConfig, null, 2)}`);
                }

                // Now subscribe to the session-specific signaling topic
                const pk = this.elements.productKey.value;
                const sn = this.elements.deviceSn.value;
                const signalTopic = `dl/${pk}/${sn}/device/${this.currentSessionId}/p2p/signal/sub`;

                this.mqttClient.subscribe(signalTopic, (err) => {
                    if (!err) {
                        this.log(`已订阅设备信令主题: ${signalTopic}`);
                        this.sendReady();
                    } else {
                        this.log(`订阅设备信令主题失败: ${err}`);
                    }
                });
            }

            sendReady() {
                this.log('发送 Ready 信号给APP');
                this.updateP2pStatus('准备就绪，等待Offer', 'connecting');

                const capabilities = { video: true, audio: true, maxResolution: "1920x1080", codecs: "H264" };
                this.sendSignalingMessage('ready', { capabilities });
            }

            async initializeMediaAndPeerConnection() {
                try {
                    this.log('初始化媒体和PeerConnection');
                    this.updateP2pStatus('获取媒体设备...', 'connecting');

                    // 检查RTC配置是否已获取
                    if (!this.rtcConfig) {
                        throw new Error('RTC配置未获取，无法创建PeerConnection');
                    }

                    if (this.localStream) {
                        this.localStream.getTracks().forEach(track => track.stop());
                    }
                    this.localStream = await navigator.mediaDevices.getUserMedia({ video: true, audio: true });
                    this.elements.localVideo.srcObject = this.localStream;
                    this.log('成功获取本地媒体流。');

                    if (this.pc) {
                        this.pc.close();
                    }

                    this.log(`=== 使用MQTT下发的RTC配置创建PeerConnection ===`);
                    this.pc = new RTCPeerConnection(this.rtcConfig);

                    this.localStream.getTracks().forEach(track => {
                        this.pc.addTrack(track, this.localStream);
                        this.log(`添加本地轨道: ${track.kind}`);
                    });

                    let iceCandidates = []; // 收集所有ICE候选者
                    let iceGatheringComplete = false; // ICE收集完成标志

                    this.pc.onicecandidate = (event) => {
                        if (event.candidate) {
                            this.log(`收集ICE候选者: ${event.candidate.candidate}`);
                            iceCandidates.push(event.candidate);
                        } else {
                            this.log('ICE候选者收集完成，准备一次性发送');
                            iceGatheringComplete = true;

                            // 一次性发送所有收集到的ICE候选者
                            if (iceCandidates.length > 0) {
                                this.log(`一次性发送 ${iceCandidates.length} 个ICE候选者`);
                                this.sendSignalingMessage('candidates', {
                                    candidates: iceCandidates
                                });
                            }
                        }
                    };

                    // 添加ICE候选者错误监控
                    this.pc.onicecandidateerror = (event) => {
                        this.log(`ICE候选者错误: ${event.errorText}`);
                        this.log(`错误代码: ${event.errorCode}`);
                        this.log(`URL: ${event.url}`);
                        this.log(`地址: ${event.address}:${event.port}`);
                    };

                    this.pc.ontrack = (event) => {
                        this.log(`接收到远程轨道: ${event.track.kind}`);
                        this.log(`轨道详细信息:`, event.track);
                        this.log(`关联的流数量: ${event.streams ? event.streams.length : 0}`);

                        if (event.track.kind === 'audio') {
                            this.log(`音频轨道信息: ${event.track.label}, 启用状态: ${event.track.enabled}, 静音状态: ${event.track.muted}`);

                            // 检查音频流是否存在
                            if (event.streams && event.streams.length > 0) {
                                this.log(`音频流数量: ${event.streams.length}`);
                                this.log(`第一个流信息:`, event.streams[0]);
                                this.elements.remoteAudio.srcObject = event.streams[0];

                                // 监控音频轨道状态
                                event.track.onended = () => this.log('远程音频轨道已结束');
                                event.track.onmute = () => this.log('远程音频轨道已静音');
                                event.track.onunmute = () => this.log('远程音频轨道已取消静音');

                                // 启动音频可视化
                                setTimeout(() => {
                                    this.log('延迟启动音频可视化，确保音频流稳定...');
                                    if (event.streams[0]) {
                                        this.log(`准备启动可视化的流:`, event.streams[0]);
                                        this.startAudioVisualization(event.streams[0]);
                                    } else {
                                        this.log('错误：音频流为空');
                                    }
                                }, 500);
                            } else {
                                this.log('警告：音频轨道没有关联的流，创建新流');
                                // 创建一个新的MediaStream来包含这个轨道
                                const newStream = new MediaStream([event.track]);
                                this.log(`新创建的流:`, newStream);
                                this.elements.remoteAudio.srcObject = newStream;

                                // 监控音频轨道状态
                                event.track.onended = () => this.log('远程音频轨道已结束');
                                event.track.onmute = () => this.log('远程音频轨道已静音');
                                event.track.onunmute = () => this.log('远程音频轨道已取消静音');

                                // 启动音频可视化
                                setTimeout(() => {
                                    this.log('延迟启动音频可视化，使用新创建的流...');
                                    this.startAudioVisualization(newStream);
                                }, 500);
                            }
                        }
                    };

                    this.pc.onconnectionstatechange = () => {
                        const state = this.pc.connectionState;
                        this.log(`P2P 连接状态: ${state}`);
                        switch (state) {
                            case 'connected':
                                this.updateP2pStatus('P2P已连接', 'connected');
                                this.sendSignalingMessage('connected');
                                this.isNegotiating = false; // 解除锁定

                                // P2P连接成功后，尝试启动音频可视化
                                setTimeout(() => {
                                    this.log('P2P连接已建立，尝试启动音频可视化...');
                                    if (this.elements.remoteAudio.srcObject) {
                                        this.log('检测到远程音频流，启动可视化...');
                                        this.startAudioVisualization(this.elements.remoteAudio.srcObject);
                                    } else {
                                        this.log('远程音频流不可用，等待音频流建立...');
                                        this.elements.visualizationStatus.textContent = '等待音频流...';
                                        this.elements.visualizationStatus.style.color = '#ff9900';

                                        // 定期检查音频流是否建立
                                        const checkAudioStream = setInterval(() => {
                                            if (this.elements.remoteAudio.srcObject) {
                                                this.log('检测到远程音频流，启动可视化...');
                                                this.startAudioVisualization(this.elements.remoteAudio.srcObject);
                                                clearInterval(checkAudioStream);
                                            } else {
                                                this.log('仍在等待音频流建立...');
                                            }
                                        }, 2000);

                                        // 30秒后停止检查
                                        setTimeout(() => {
                                            clearInterval(checkAudioStream);
                                            if (!this.elements.remoteAudio.srcObject) {
                                                this.log('30秒内未检测到音频流，可能存在问题');
                                                this.elements.visualizationStatus.textContent = '音频流未建立';
                                                this.elements.visualizationStatus.style.color = '#ff0000';
                                            }
                                        }, 30000);
                                    }
                                }, 1000);
                                break;
                            case 'disconnected':
                            case 'failed':
                                this.updateP2pStatus('P2P连接断开', 'disconnected');
                                this.isNegotiating = false; // 解除锁定
                                break;
                            case 'closed':
                                this.updateP2pStatus('P2P连接关闭', 'disconnected');
                                this.isNegotiating = false; // 解除锁定
                                this.closePeerConnection();
                                break;
                        }
                    };
                    return true;
                } catch (error) {
                    this.log(`媒体或P2P初始化失败: ${error}`);
                    this.updateP2pStatus('初始化失败', 'disconnected');
                    return false;
                }
            }

            sendSignalingMessage(type, dataPayload = {}) {
                if (!this.mqttClient || !this.mqttClient.connected || !this.currentSessionId) {
                    this.log(`无法发送信令 (${type})：MQTT未连接或无会话。`);
                    return;
                }
                const pk = this.elements.productKey.value;
                const sn = this.elements.deviceSn.value;
                const targetTopic = `dl/${pk}/${sn}/app/${this.currentSessionId}/p2p/signal/sub`;

                const message = {
                    cmd: 'WEB_RTC',
                    ts: Date.now(),
                    msgId: `device_${Date.now()}`,
                    data: {
                        type,
                        sessionId: this.currentSessionId,
                        from: sn,
                        to: this.currentAppId,
                        ...dataPayload
                    }
                };

                const msgString = JSON.stringify(message);
                this.log(`⬆️ [MQTT-OUT] Topic: ${targetTopic}\nPayload: ${msgString}`);
                this.mqttClient.publish(targetTopic, msgString);
            }

            async handleSignalingMessage(message) {
                const data = message.data;
                if (!data || data.sessionId !== this.currentSessionId) {
                    this.log('信令消息无数据或会话ID不匹配，已忽略。');
                    return;
                }

                const { type } = data;
                this.log(`处理信令: ${type}`);

                try {
                    switch (type) {
                        case 'offer':
                            if (this.isNegotiating) {
                                this.log('警告：正在协商中，忽略新的Offer请求。');
                                return;
                            }
                            this.isNegotiating = true; // 锁定
                            this.updateP2pStatus('收到Offer，处理中...', 'connecting');

                            if (await this.initializeMediaAndPeerConnection()) {
                                this.log(`接收到的Offer SDP内容:`);
                                this.log(data.sdp);

                                await this.pc.setRemoteDescription(new RTCSessionDescription(data));
                                const answer = await this.pc.createAnswer();

                                this.log(`生成的Answer SDP内容:`);
                                this.log(answer.sdp);

                                await this.pc.setLocalDescription(answer);
                                this.sendSignalingMessage('answer', { sdp: answer.sdp });
                                this.updateP2pStatus('Answer已发送', 'connecting');
                            } else {
                                this.isNegotiating = false; // 初始化失败，解除锁定
                            }
                            break;
                        case 'candidate':
                            if (this.pc && this.pc.remoteDescription) {
                                await this.pc.addIceCandidate(new RTCIceCandidate(data.candidate));
                            }
                            break;
                        case 'candidates':
                            if (this.pc && this.pc.remoteDescription && data.candidates) {
                                this.log(`批量处理 ${data.candidates.length} 个ICE候选者`);
                                for (const candidateData of data.candidates) {
                                    try {
                                        await this.pc.addIceCandidate(new RTCIceCandidate(candidateData));
                                    } catch (error) {
                                        this.log(`添加ICE候选者失败: ${error.message}`);
                                    }
                                }
                                this.log('批量ICE候选者处理完成');
                            }
                            break;
                        case 'permission_request':
                            if (data.type === 'create_permission') {
                                this.log('收到权限请求，发送确认...');
                                // 发送权限确认
                                this.sendSignalingMessage('permission_response', {
                                    type: 'permission_granted',
                                    target: data.from
                                });

                                // 同时也请求对方的权限
                                this.sendSignalingMessage('permission_request', {
                                    type: 'create_permission',
                                    target: data.from
                                });
                            }
                            break;
                        case 'permission_response':
                            if (data.type === 'permission_granted') {
                                this.log('权限请求已被确认');
                            }
                            break;
                        case 'bye':
                            this.log('收到APP的断开信号，正在关闭连接。');
                            this.updateP2pStatus('对方已断开', 'disconnected');
                            this.closePeerConnection();
                            break;
                        case 'keepalive':
                            this.log('收到APP心跳。');
                            // Can respond if needed.
                            break;
                    }
                } catch (error) {
                    this.log(`处理信令 ${type} 失败: ${error}`);
                    this.isNegotiating = false; // 出错时解除锁定
                }
            }
        }

        window.p2pDevice = new P2PDevice();
    </script>
</body>

</html>